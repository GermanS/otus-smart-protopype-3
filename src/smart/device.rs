use core::fmt;

// Трейт `Named` предоставляет функциональность для получения
/// имени объекта.
///
/// Этот трейд определяет метод `name`, который возвращает
/// строковое представление имени объекта.
///
/// # Пример
///
/// ```
/// use crate::lesson_4::smart::Named;
///
/// struct Robot {
///     name: String,
/// }
///
/// impl Named for Robot {
///     fn name(&self) -> &str {
///         &self.name
///     }
/// }
///
/// let robot = Robot { name: String::from("Alice") };
/// assert_eq!(robot.name(), "Alice");
/// ```
pub trait Named {
    /// Возвращает ссылку на строку, представляющую имя объекта.
    ///
    /// # Возвращаемое значение
    /// Возвращает ссылку на строку, содержащую имя.
    fn name(&self) -> &str;
}

/// Трейт `Pluggable`, представляющий устройства, которые могут быть
/// подключены к сети.
///
/// Этот трейт расширяет функциональность трейта `Named`, обеспечивая
/// доступ к методу `name`, который возвращает имя устройства. Трейт
/// `Pluggable` может быть использован для описания объектов, которые
/// представляют устройства, способные подключаться к источникам питания
/// или сетям, например, умные розетки, лампочки и другие устройства.
///
/// # Сущности
///
/// Все структуры, которые реализуют трейт `Pluggable`, должны также
/// реализовывать трейт `Named`. Это гарантирует, что для любого
/// подключаемого устройства можно будет получить его имя.
///
/// ## Пример
///
/// ```plaintext
/// use crate::lesson_4::smart::Named;
/// pub struct SmartSocket {
///     name: String,
/// }
///
/// impl Named for SmartSocket {
///     fn name(&self) -> &str {
///         &self.name
///     }
/// }
///
/// impl Pluggable for SmartSocket {}
/// ```
///
/// В этом примере структура `SmartPlug` реализует как трейт `Named`,
/// так и трейт `Pluggable`, что позволяет использовать её в контекстах,
/// требующих доступа к имени устройства и его функциональности подключения.
pub trait Pluggable: Named {}

/// Представляет умную розетку.
///
/// Структура `SmartSocket` используется для управления умной розеткой с
/// указанным названием.
///
/// # Поля
///
/// - `name`: Строка, представляющая имя умной розетки. Это имя может
///     быть использовано для идентификации розетки в пользовательском интерфейсе.
///
/// # Примечание
///
/// Умные розетки могут быть частью системы IoT и могут поддерживать
/// различные протоколы подключения, такие как Wi-Fi или Zigbee.
/// Дополнительные методы и функции могут быть добавлены для работы
/// с такими протоколами.
///
/// # Пример
///
/// ```plaintext
/// let my_socket = SmartSocket {
///     name: String::from("Living Room Socket"),
/// };
/// ```
#[derive(Debug, Clone)]
pub struct SmartSocket {
    name: String,
}

impl SmartSocket {
    /// Создает новый экземпляр `SmartSocket`.
    ///
    /// Этот метод является конструктором для структуры `SmartSocket`,
    /// который позволяет создать розетку с заданным именем. Имя
    /// умной розетки может быть использовано для дальнейшего взаимодействия
    /// с устройством, например, для отображения  в отчете.
    ///
    /// # Аргументы
    ///
    /// * `name` - Строка, представляющая имя для умной розетки. Это имя
    ///   должно быть уникальным, если в системе присутствует несколько
    ///   розеток.
    ///
    /// # Пример
    ///
    /// ```plaintext
    /// let socket = SmartSocket::new(String::from("Bedroom Socket"));
    /// ```
    ///
    /// # Возвращаемое значение
    ///
    /// Возвращает новый экземпляр `SmartSocket` с заданным именем.
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

/// Реализация трейта `Named` для структуры `SmartSocket`.
///
/// Этот трейт определяет метод `name`, который возвращает имя умной
/// розетки. Он позволяет использовать `SmartSocket` в контекстах,
/// где требуется доступ к имени устройства.
///
/// # Методы
///
/// ## `name(&self) -> &str`
///
/// Возвращает ссылку на строковый слайс, представляющую имя умной розетки.
///
/// # Пример
///
/// ```rust
/// use crate::lesson_4::smart::Named;
/// use lesson_4::smart::device::SmartSocket;
/// // Предполагается, что структура SmartSocket уже была определена и
/// // реализован трейт Named.
///
/// let socket = SmartSocket::new(String::from("Kitchen Socket"));
/// let socket_name = socket.name();
/// assert_eq!(socket_name, "Kitchen Socket");
/// ```
impl Named for SmartSocket {
    fn name(&self) -> &str {
        &self.name
    }
}

/// Реализация трейта `Pluggable` для структуры `SmartSocket`.
///
/// Эта реализация позволяет использовать `SmartSocket` в контексте
/// подключаемых устройств, обеспечивая доступ к методу `name`,
/// унаследованному от трейта `Named`.
///
/// Реализация трейта `Pluggable` позволяет пользователю работать с
/// объектами `SmartSocket` как с подключаемыми устройствами,
/// экономя усилия на повторном определении методов, необходимых
/// для интероперации с другими модулями или библиотеками, требующими
/// функциональность подключения.
///
/// # Пример
///
/// ```rust
/// use crate::lesson_4::smart::Named;
/// use lesson_4::smart::device::SmartSocket;
/// // Предполагается, что структура SmartSocket и трейт Named уже
/// // определены.
///
/// let socket = SmartSocket::new(String::from("Living Room Socket"));
/// // Теперь мы можем использовать socket как подключаемое устройство.
/// let socket_name = socket.name();
/// assert_eq!(socket_name, "Living Room Socket");
/// ```
///
/// В этом примере `socket` можно использовать как подключаемое
/// устройство благодаря реализации трейта `Pluggable`, при этом
/// сохранена возможность доступа к его имени через метод `name`.
impl Pluggable for SmartSocket {}

/// Реализация трейта `Display` для структуры `SmartSocket`.
///
/// Эта реализация позволяет выводить представление умной розетки в отчете.
///
/// При вызове метода `fmt`, информация о `SmartSocket` будет
/// отформатирована в строку, содержащую тип устройства и его имя.
///
/// # Пример
///
/// ```plaintext
/// // Предполагается, что структура SmartSocket и её реализация метода `name` уже определены.
///
/// let socket = SmartSocket::new(String::from("Living Room Socket"));
/// println!("{}", socket);
/// ```
///
/// В результате выполнения этого кода будет выведено:
/// ```plaintext
/// ----> Device: Socket[Living Room Socket]
/// ```
impl fmt::Display for SmartSocket {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "----> Device: Socket[{}]", self.name())
    }
}

/// Структура `SmartThermometer`, представляющая умный термометр.
///
/// Структура инкапсулирует информацию о термометре, включая его имя.
///
/// # Поля
///
/// - `name`: `String` — имя термометра, которое может быть использовано для
///   идентификации устройства в пользовательском интерфейсе или в системе.
///   Например, имя может использоваться для различения между термометрами
///   в разных помещениях.
///
/// # Пример
///
/// ```rust
/// use crate::lesson_4::smart::Named;
/// use lesson_4::smart::device::SmartThermometer;
/// // Создание нового экземпляра умного термометра.
/// let thermometer = SmartThermometer::new( String::from("Kitchen Thermometer") );
/// // Получение имени термометра.
/// println!("Thermometer Name: {}", thermometer.name());
/// ```
///
/// В этом примере мы создаем новый `SmartThermometer`, называя его
/// "Kitchen Thermometer", и выводим его имя на экран.
#[derive(Clone)]
pub struct SmartThermometer {
    name: String,
}

impl SmartThermometer {
    /// Создает новый экземпляр `SmartThermometer`.
    ///
    /// Этот метод инициализирует новый умный термометр с указанным именем.
    /// Он принимает строку, представляющую имя термометра, и возвращает
    /// экземпляр `SmartThermometer`.
    ///
    /// # Параметры
    ///
    /// - `name`: `String` - имя термометра, которое используется для
    ///   его идентификации. Имя может быть любым, например, "Кухонный
    ///   термометр" или "Уличный термометр".
    ///
    /// # Возвращаемое значение
    ///
    /// Возвращает экземпляр `SmartThermometer`, который инициализирован
    /// с переданным именем.
    ///
    /// # Пример
    ///
    /// ```rust
    /// use crate::lesson_4::smart::Named;
    /// use lesson_4::smart::device::SmartThermometer;
    /// // Создание нового экземпляра SmartThermometer.
    /// let thermometer = SmartThermometer::new(String::from("Kitchen Thermometer"));
    /// println!("Thermometer Name: {}", thermometer.name());
    /// ```
    ///
    /// В этом примере создается новый термометр с именем "Kitchen Thermometer"
    /// и выводится его имя на экран.
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

/// Реализация трейта `Named` для структуры `SmartThermometer`.
///
/// Этот трейт определяет метод для получения имени устройства,
/// что позволяет легко идентифицировать умный термометр
impl Named for SmartThermometer {
    /// Возвращает ссылку строковый слайс имени термометра
    ///
    /// Этот метод позволяет получить имя умного термометра, которое
    /// было задано при создании экземпляра. Имя возвращается как
    /// ссылка на строковый слайс, что позволяет избежать лишнего выделения памяти.
    ///
    /// # Возвращаемое значение
    ///
    /// Возвращает ссылку на строку (`&str`), представляющую имя термометра.
    ///
    /// # Пример
    ///
    /// ```rust
    /// use crate::lesson_4::smart::Named;
    /// use lesson_4::smart::device::SmartThermometer;
    /// // Предполагается, что структура SmartThermometer и метод new уже определены.
    /// let thermometer = SmartThermometer::new(String::from("Kitchen Thermometer"));
    /// println!("The thermometer's name is: {}", thermometer.name());
    /// ```
    ///
    /// В этом примере мы создаем новый экземпляр `SmartThermometer`
    /// и выводим его имя на экран.
    fn name(&self) -> &str {
        &self.name
    }
}

/// Реализация трейта `Pluggable` для структуры `SmartThermometer`.
///
/// Эта реализация позволяет использовать `SmartThermometer` в контексте
/// подключаемых устройств, обеспечивая доступ к методу `name`,
/// унаследованному от трейта `Named`.
///
/// Реализация трейта `Pluggable` позволяет пользователю работать с
/// объектами `SmartSocket` как с подключаемыми устройствами,
/// экономя усилия на повторном определении методов, необходимых
/// для интероперации с другими модулями или библиотеками, требующими
/// функциональность подключения.
///
/// # Пример
/// ```rust
/// use crate::lesson_4::smart::Named;
/// use lesson_4::smart::device::SmartThermometer;
/// // Предполагается, что структура SmartThermometer и трейт Named уже
/// // определены.
///
/// let termometer = SmartThermometer::new(String::from("Living Room Thermometert"));
/// // Теперь мы можем использовать termo как подключаемое устройство.
/// let thermo_name = termometer.name();
/// assert_eq!(thermo_name, "Living Room Thermometert");
/// ```
///
/// В этом примере `termometer` можно использовать как подключаемое
/// устройство благодаря реализации трейта `Pluggable`, при этом
/// сохранена возможность доступа к его имени через метод `name`.
impl Pluggable for SmartThermometer {}

/// Реализация трейта `fmt::Display` для структуры `SmartThermometer`.
///
/// Этот трейт позволяет формировать строковое представление умного термометра,
/// что упрощает вывод информации о термометре как в консоль, так и в других
/// текстовых форматах. Использование `fmt::Display` позволяет выводить
/// информацию о объекте через стандартные форматы вывода.
///
/// # Метод
///
/// ## fmt
///
/// Этот метод определяет, как именно будет форматироваться
/// представление `SmartThermometer`. В текущей реализации, метод
/// возвращает строку, содержащую имя термометра, оформленную в виде:
///
/// ```plaintext
/// ----> Device: Thermometer[имя_термометра]
/// ```
///
/// # Пример
///
/// Пример использования текущей реализации `fmt::Display`:
///
/// ```rust
/// use lesson_4::smart::device::SmartThermometer;
/// // Предполагается, что структура SmartThermometer и метод new определены.
/// let thermometer = SmartThermometer::new(String::from("Kitchen Thermometer"));
/// println!("{}", thermometer);
/// ```
///
/// В этом примере мы создаем новый экземпляр `SmartThermometer` и
/// выводим его в консоль. Вывод будет следующим:
///
/// ```plaintext
/// ----> Device: Thermometer[Kitchen Thermometer]
/// ```
impl fmt::Display for SmartThermometer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "----> Device: Thermometer[{}]", self.name())
    }
}
